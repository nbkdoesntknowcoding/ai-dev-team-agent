"""
Human review interface for the multi-agent development system.

This module provides the interface for human stakeholders to review and provide
feedback on artifacts generated by the agent system. It handles displaying
agent outputs in appropriate formats, collecting feedback, and routing that
feedback back to the relevant agents.
"""

import json
import logging
import asyncio
from datetime import datetime
from typing import Dict, List, Optional, Any, Union, Callable, Awaitable
from enum import Enum
import uuid
import re
from pathlib import Path
import difflib

from pydantic import BaseModel, Field, validator

# Set up logging
logger = logging.getLogger(__name__)


class ReviewStatus(str, Enum):
    """Possible statuses for a review."""
    PENDING = "pending"
    APPROVED = "approved"
    REJECTED = "rejected"
    NEEDS_CLARIFICATION = "needs_clarification"
    PARTIALLY_APPROVED = "partially_approved"


class FeedbackType(str, Enum):
    """Types of feedback that can be given."""
    GENERAL = "general"
    CODE_QUALITY = "code_quality"
    FUNCTIONALITY = "functionality"
    DESIGN = "design"
    PERFORMANCE = "performance"
    SECURITY = "security"
    DOCUMENTATION = "documentation"
    USABILITY = "usability"


class FeedbackItem(BaseModel):
    """A specific piece of feedback from a reviewer."""
    id: str = Field(default_factory=lambda: str(uuid.uuid4()))
    feedback_type: FeedbackType
    comment: str
    location: Optional[str] = None  # e.g., "file.py:23" or "component_name"
    severity: Optional[str] = None  # e.g., "high", "medium", "low"
    suggested_changes: Optional[str] = None
    created_at: str = Field(default_factory=lambda: datetime.now().isoformat())


class ReviewSubmission(BaseModel):
    """A complete review submission from a human reviewer."""
    id: str = Field(default_factory=lambda: str(uuid.uuid4()))
    task_id: str
    artifact_id: Optional[str] = None
    reviewer_id: str
    status: ReviewStatus
    feedback_items: List[FeedbackItem] = Field(default_factory=list)
    summary: Optional[str] = None
    created_at: str = Field(default_factory=lambda: datetime.now().isoformat())


class DisplayFormat(str, Enum):
    """Formats for displaying content to reviewers."""
    CODE = "code"
    TEXT = "text"
    IMAGE = "image"
    DIAGRAM = "diagram"
    MARKDOWN = "markdown"
    HTML = "html"
    JSON = "json"
    DIFF = "diff"


class ReviewableArtifact(BaseModel):
    """An artifact to be reviewed by a human."""
    id: str = Field(default_factory=lambda: str(uuid.uuid4()))
    task_id: str
    agent_id: str
    agent_name: str
    title: str
    description: Optional[str] = None
    content: Any
    content_format: DisplayFormat
    metadata: Dict[str, Any] = Field(default_factory=dict)
    created_at: str = Field(default_factory=lambda: datetime.now().isoformat())
    previous_version_id: Optional[str] = None


class ReviewCallback(BaseModel):
    """Configuration for callback when review is complete."""
    agent_id: str
    method: str
    kwargs: Dict[str, Any] = Field(default_factory=dict)


class ReviewRequest(BaseModel):
    """A request for human review of an artifact."""
    id: str = Field(default_factory=lambda: str(uuid.uuid4()))
    artifact: ReviewableArtifact
    instructions: str
    priority: str = "medium"
    deadline: Optional[str] = None
    requested_by: str
    callback: Optional[ReviewCallback] = None
    status: str = "pending"
    created_at: str = Field(default_factory=lambda: datetime.now().isoformat())


class ReviewInterface:
    """Interface for human review of agent outputs."""
    
    def __init__(
        self,
        storage_dir: Optional[str] = None,
        review_handlers: Optional[Dict[DisplayFormat, Callable]] = None,
        shared_memory: Any = None,
        notification_callback: Optional[Callable[[ReviewRequest], Awaitable[None]]] = None,
    ):
        """Initialize the review interface.
        
        Args:
            storage_dir: Directory to store review artifacts
            review_handlers: Specialized handlers for different content formats
            shared_memory: Shared memory interface for system communication
            notification_callback: Async callback for notifying humans of review requests
        """
        self.storage_dir = Path(storage_dir) if storage_dir else None
        if self.storage_dir and not self.storage_dir.exists():
            self.storage_dir.mkdir(parents=True)
            
        self.review_handlers = review_handlers or {}
        self.shared_memory = shared_memory
        self.notification_callback = notification_callback
        
        # Internal storage
        self.pending_reviews: Dict[str, ReviewRequest] = {}
        self.completed_reviews: Dict[str, ReviewSubmission] = {}
        self.artifacts: Dict[str, ReviewableArtifact] = {}
        
        logger.info("Review interface initialized")
    
    async def create_review_request(
        self,
        task_id: str,
        agent_id: str,
        agent_name: str,
        title: str,
        content: Any,
        content_format: Union[DisplayFormat, str],
        description: Optional[str] = None,
        instructions: Optional[str] = None,
        priority: str = "medium",
        deadline: Optional[str] = None,
        metadata: Optional[Dict[str, Any]] = None,
        previous_version_id: Optional[str] = None,
        callback: Optional[Dict[str, Any]] = None
    ) -> str:
        """Create a new request for human review.
        
        Args:
            task_id: ID of the task that produced the artifact
            agent_id: ID of the agent that produced the artifact
            agent_name: Name of the agent that produced the artifact
            title: Title for the review
            content: Content to be reviewed
            content_format: Format of the content
            description: Optional description of the artifact
            instructions: Optional specific instructions for the reviewer
            priority: Priority of the review ("low", "medium", "high", "critical")
            deadline: Optional deadline for the review
            metadata: Optional additional metadata
            previous_version_id: Optional ID of a previous version for comparison
            callback: Optional callback configuration for when review is complete
            
        Returns:
            ID of the created review request
        """
        # Ensure content_format is a DisplayFormat enum
        if isinstance(content_format, str):
            content_format = DisplayFormat(content_format)
        
        # Format-specific preprocessing
        if content_format == DisplayFormat.CODE and isinstance(content, str):
            # Ensure code has proper line endings and is stripped
            content = content.replace('\r\n', '\n').strip()
            
        elif content_format == DisplayFormat.MARKDOWN and isinstance(content, str):
            # Ensure markdown has proper line endings
            content = content.replace('\r\n', '\n')
            
        elif content_format == DisplayFormat.JSON and not isinstance(content, str):
            # Convert to formatted JSON string if not already a string
            content = json.dumps(content, indent=2)
        
        # Save content to file if storage_dir is configured
        content_path = None
        if self.storage_dir:
            filename = f"{task_id}_{datetime.now().strftime('%Y%m%d_%H%M%S')}"
            
            # Add appropriate extension
            if content_format == DisplayFormat.CODE:
                # Try to determine language from metadata or fall back to txt
                lang = metadata.get("language", "txt") if metadata else "txt"
                filename = f"{filename}.{lang}"
            elif content_format == DisplayFormat.MARKDOWN:
                filename = f"{filename}.md"
            elif content_format == DisplayFormat.HTML:
                filename = f"{filename}.html"
            elif content_format == DisplayFormat.JSON:
                filename = f"{filename}.json"
            else:
                filename = f"{filename}.txt"
            
            content_path = self.storage_dir / filename
            
            # Save content to file
            if isinstance(content, str):
                with open(content_path, "w", encoding="utf-8") as f:
                    f.write(content)
            else:
                with open(content_path, "w", encoding="utf-8") as f:
                    json.dump(content, f, indent=2)
            
            logger.info(f"Saved review content to {content_path}")
        
        # Create the artifact to be reviewed
        artifact = ReviewableArtifact(
            task_id=task_id,
            agent_id=agent_id,
            agent_name=agent_name,
            title=title,
            description=description,
            content=content,
            content_format=content_format,
            metadata=metadata or {},
            previous_version_id=previous_version_id
        )
        
        if content_path:
            artifact.metadata["file_path"] = str(content_path)
        
        # Create callback configuration if provided
        review_callback = None
        if callback:
            review_callback = ReviewCallback(**callback)
        
        # Create the review request
        request = ReviewRequest(
            artifact=artifact,
            instructions=instructions or f"Please review this {content_format} artifact and provide feedback.",
            priority=priority,
            deadline=deadline,
            requested_by=agent_name,
            callback=review_callback
        )
        
        # Store the request and artifact
        self.pending_reviews[request.id] = request
        self.artifacts[artifact.id] = artifact
        
        # Store in shared memory if available
        if self.shared_memory:
            self.shared_memory.store(
                key=f"review_request_{request.id}",
                value=request.dict(),
                category="review_requests"
            )
            
            self.shared_memory.store(
                key=f"artifact_{artifact.id}",
                value=artifact.dict(),
                category="artifacts"
            )
        
        # Notify through callback if configured
        if self.notification_callback:
            await self.notification_callback(request)
        
        logger.info(f"Created review request {request.id} for {title}")
        return request.id
    
    def get_review_request(self, request_id: str) -> Optional[ReviewRequest]:
        """Get a specific review request.
        
        Args:
            request_id: ID of the review request
            
        Returns:
            ReviewRequest if found, None otherwise
        """
        # Check local storage
        if request_id in self.pending_reviews:
            return self.pending_reviews[request_id]
        
        # Check shared memory if available
        if self.shared_memory:
            request_data = self.shared_memory.retrieve(
                key=f"review_request_{request_id}",
                category="review_requests"
            )
            
            if request_data:
                request = ReviewRequest(**request_data)
                # Cache locally
                self.pending_reviews[request_id] = request
                return request
        
        return None
    
    def get_artifact(self, artifact_id: str) -> Optional[ReviewableArtifact]:
        """Get a specific artifact.
        
        Args:
            artifact_id: ID of the artifact
            
        Returns:
            ReviewableArtifact if found, None otherwise
        """
        # Check local storage
        if artifact_id in self.artifacts:
            return self.artifacts[artifact_id]
        
        # Check shared memory if available
        if self.shared_memory:
            artifact_data = self.shared_memory.retrieve(
                key=f"artifact_{artifact_id}",
                category="artifacts"
            )
            
            if artifact_data:
                artifact = ReviewableArtifact(**artifact_data)
                # Cache locally
                self.artifacts[artifact_id] = artifact
                return artifact
        
        return None
    
    def get_pending_reviews(
        self, 
        agent_id: Optional[str] = None, 
        priority: Optional[str] = None
    ) -> List[ReviewRequest]:
        """Get pending review requests, optionally filtered.
        
        Args:
            agent_id: Optional agent ID to filter by
            priority: Optional priority level to filter by
            
        Returns:
            List of matching review requests
        """
        # Start with all pending reviews
        results = list(self.pending_reviews.values())
        
        # Apply filters
        if agent_id:
            results = [r for r in results if r.artifact.agent_id == agent_id]
        
        if priority:
            results = [r for r in results if r.priority == priority]
        
        # Sort by priority and creation time
        priority_map = {"critical": 0, "high": 1, "medium": 2, "low": 3}
        results.sort(
            key=lambda r: (
                priority_map.get(r.priority, 4),
                r.created_at
            )
        )
        
        return results
    
    async def submit_review(
        self,
        request_id: str,
        reviewer_id: str,
        status: Union[ReviewStatus, str],
        feedback_items: List[Dict[str, Any]] = None,
        summary: Optional[str] = None
    ) -> bool:
        """Submit a review for a pending request.
        
        Args:
            request_id: ID of the review request
            reviewer_id: ID of the human reviewer
            status: Status of the review
            feedback_items: List of feedback items
            summary: Optional summary of the review
            
        Returns:
            True if successful, False otherwise
        """
        # Get the review request
        request = self.get_review_request(request_id)
        if not request:
            logger.error(f"Review request {request_id} not found")
            return False
        
        # Ensure status is a ReviewStatus enum
        if isinstance(status, str):
            status = ReviewStatus(status)
        
        # Convert feedback items to models
        feedback_models = []
        if feedback_items:
            for item in feedback_items:
                # Ensure feedback_type is a FeedbackType enum
                if isinstance(item.get("feedback_type"), str):
                    item["feedback_type"] = FeedbackType(item["feedback_type"])
                
                feedback_models.append(FeedbackItem(**item))
        
        # Create the review submission
        submission = ReviewSubmission(
            task_id=request.artifact.task_id,
            artifact_id=request.artifact.id,
            reviewer_id=reviewer_id,
            status=status,
            feedback_items=feedback_models,
            summary=summary
        )
        
        # Store the submission
        self.completed_reviews[submission.id] = submission
        
        # Update request status
        request.status = "completed"
        
        # Remove from pending reviews
        if request_id in self.pending_reviews:
            del self.pending_reviews[request_id]
        
        # Store in shared memory if available
        if self.shared_memory:
            self.shared_memory.store(
                key=f"review_submission_{submission.id}",
                value=submission.dict(),
                category="review_submissions"
            )
            
            # Update request status
            self.shared_memory.store(
                key=f"review_request_{request_id}",
                value=request.dict(),
                category="review_requests"
            )
        
        # Process the review through the callback if configured
        if request.callback:
            await self._process_review_callback(request.callback, submission)
        
        logger.info(f"Received review submission {submission.id} for request {request_id}")
        return True
    
    async def _process_review_callback(
        self, 
        callback: ReviewCallback, 
        submission: ReviewSubmission
    ) -> None:
        """Process the callback for a completed review.
        
        Args:
            callback: Callback configuration
            submission: The review submission to process
        """
        try:
            # Check if we have the agent registry in shared memory
            if not self.shared_memory:
                logger.warning("Cannot process review callback: No shared memory available")
                return
            
            # Get the agent registry
            agent_registry = self.shared_memory.retrieve(
                key="agent_registry",
                category="system"
            )
            
            if not agent_registry or callback.agent_id not in agent_registry:
                logger.warning(f"Cannot process review callback: Agent {callback.agent_id} not found")
                return
            
            # Get the agent
            agent_info = agent_registry[callback.agent_id]
            
            # Prepare feedback data
            feedback_data = {
                "review_id": submission.id,
                "task_id": submission.task_id,
                "status": submission.status,
                "feedback_items": [item.dict() for item in submission.feedback_items],
                "summary": submission.summary,
                "approved": submission.status == ReviewStatus.APPROVED,
                "feedback": submission.summary or ""
            }
            
            # Add any additional kwargs from the callback
            feedback_data.update(callback.kwargs)
            
            # Add to task queue
            task_queue = self.shared_memory.retrieve(
                key="task_queue",
                category="system"
            ) or []
            
            task_queue.append({
                "agent_id": callback.agent_id,
                "method": callback.method,
                "kwargs": feedback_data,
                "priority": "high",
                "timestamp": datetime.now().isoformat()
            })
            
            # Update task queue
            self.shared_memory.store(
                key="task_queue",
                value=task_queue,
                category="system"
            )
            
            logger.info(f"Queued review callback for agent {callback.agent_id}, method {callback.method}")
            
        except Exception as e:
            logger.error(f"Error processing review callback: {str(e)}")
    
    def get_review_submission(self, submission_id: str) -> Optional[ReviewSubmission]:
        """Get a specific review submission.
        
        Args:
            submission_id: ID of the review submission
            
        Returns:
            ReviewSubmission if found, None otherwise
        """
        # Check local storage
        if submission_id in self.completed_reviews:
            return self.completed_reviews[submission_id]
        
        # Check shared memory if available
        if self.shared_memory:
            submission_data = self.shared_memory.retrieve(
                key=f"review_submission_{submission_id}",
                category="review_submissions"
            )
            
            if submission_data:
                submission = ReviewSubmission(**submission_data)
                # Cache locally
                self.completed_reviews[submission_id] = submission
                return submission
        
        return None
    
    def get_reviews_for_task(self, task_id: str) -> List[ReviewSubmission]:
        """Get all review submissions for a specific task.
        
        Args:
            task_id: ID of the task
            
        Returns:
            List of review submissions for the task
        """
        # Collect from local storage
        submissions = [
            submission for submission in self.completed_reviews.values()
            if submission.task_id == task_id
        ]
        
        # Add from shared memory if available
        if self.shared_memory:
            # Get all review submission keys
            submission_keys = self.shared_memory.get_keys(category="review_submissions")
            
            for key in submission_keys:
                # Skip if we already have this submission locally
                if key.replace("review_submission_", "") in self.completed_reviews:
                    continue
                
                submission_data = self.shared_memory.retrieve(key, "review_submissions")
                if submission_data and submission_data.get("task_id") == task_id:
                    submission = ReviewSubmission(**submission_data)
                    submissions.append(submission)
                    # Cache locally
                    self.completed_reviews[submission.id] = submission
        
        # Sort by creation time
        submissions.sort(key=lambda s: s.created_at)
        
        return submissions
    
    def generate_diff(
        self, 
        original_content: str, 
        updated_content: str, 
        context_lines: int = 3,
        filename: Optional[str] = None
    ) -> str:
        """Generate a unified diff between two versions of content.
        
        Args:
            original_content: Original content
            updated_content: Updated content
            context_lines: Number of context lines to include
            filename: Optional filename for display
            
        Returns:
            Unified diff as a string
        """
        # Split content into lines
        original_lines = original_content.splitlines(True)
        updated_lines = updated_content.splitlines(True)
        
        # Generate diff
        filename = filename or "file"
        diff = difflib.unified_diff(
            original_lines,
            updated_lines,
            fromfile=f"{filename} (original)",
            tofile=f"{filename} (updated)",
            n=context_lines
        )
        
        return "".join(diff)
    
    def format_content_for_display(
        self,
        content: Any,
        content_format: DisplayFormat,
        syntax_highlight: bool = True
    ) -> Dict[str, Any]:
        """Format content for display in a review interface.
        
        Args:
            content: The content to format
            content_format: The format of the content
            syntax_highlight: Whether to apply syntax highlighting
            
        Returns:
            Dictionary with formatted content and display properties
        """
        # Check if we have a specialized handler for this format
        if content_format in self.review_handlers:
            return self.review_handlers[content_format](content, syntax_highlight)
        
        # Default formatting based on content type
        result = {
            "content": content,
            "format": content_format,
            "syntax_highlight": syntax_highlight
        }
        
        # Add format-specific properties
        if content_format == DisplayFormat.CODE:
            # Try to detect language
            lang = "text"
            if isinstance(content, str):
                # Simple language detection based on common patterns
                if re.search(r'^\s*(import|from|def|class)\s', content, re.MULTILINE):
                    lang = "python"
                elif re.search(r'^\s*(function|const|let|var|import)\s', content, re.MULTILINE):
                    lang = "javascript"
                elif re.search(r'<\?php', content):
                    lang = "php"
                elif re.search(r'<html', content, re.IGNORECASE):
                    lang = "html"
                elif re.search(r'^\s*(public|private|class|interface)\s', content, re.MULTILINE):
                    lang = "java"
            
            result["language"] = lang
            result["line_numbers"] = True
        
        elif content_format == DisplayFormat.DIFF:
            result["language"] = "diff"
            result["line_numbers"] = True
        
        return result
    
    def clear_completed_reviews(self, days_old: int = 30) -> int:
        """Clear completed reviews older than specified days.
        
        Args:
            days_old: Age in days for reviews to clear
            
        Returns:
            Number of reviews cleared
        """
        cutoff = datetime.now().timestamp() - (days_old * 24 * 60 * 60)
        to_remove = []
        
        for review_id, submission in self.completed_reviews.items():
            try:
                review_time = datetime.fromisoformat(submission.created_at).timestamp()
                if review_time < cutoff:
                    to_remove.append(review_id)
            except (ValueError, TypeError):
                # If we can't parse the date, keep the review
                continue
        
        # Remove from local storage
        for review_id in to_remove:
            del self.completed_reviews[review_id]
            
            # Remove from shared memory if available
            if self.shared_memory:
                self.shared_memory.delete(
                    key=f"review_submission_{review_id}",
                    category="review_submissions"
                )
        
        logger.info(f"Cleared {len(to_remove)} completed reviews older than {days_old} days")
        return len(to_remove)


async def notify_review_slack(request: ReviewRequest) -> None:
    """Example notification callback for Slack.
    
    This would be implemented to send a notification to a Slack channel
    when a new review request is created.
    
    Args:
        request: The review request
    """
    # This is a placeholder for an actual Slack integration
    logger.info(
        f"SLACK NOTIFICATION: New review request '{request.artifact.title}' "
        f"from {request.artifact.agent_name}, priority: {request.priority}"
    )


async def notify_review_email(request: ReviewRequest) -> None:
    """Example notification callback for email.
    
    This would be implemented to send an email notification
    when a new review request is created.
    
    Args:
        request: The review request
    """
    # This is a placeholder for an actual email integration
    logger.info(
        f"EMAIL NOTIFICATION: New review request '{request.artifact.title}' "
        f"from {request.artifact.agent_name}, priority: {request.priority}"
    )